#define digi_tree_cxx
#include "digi_tree_lab2018.h"
#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <TH1F.h>

// open the file when running the macro:
//      > root -l 
//      Root > .L digi_tree_lab2017.C
//      Root > digi_tree * t =new digi_tree("xx") (to open file runxx_wave.root)
//      Root > t->Loop()  // Loop on all entries

void digi_tree::Loop()
{

   // definizione di alcuni parametri utili
   int time_range_low=0;  //limite inferiore della finestra temporale da considerare (NB: in bin di tempo, non in ns)
   int time_range_hi=1024;  //limite superiore della finestra temporale da considerare (NB: in bin di tempo, non in ns)
   bool draw_signal=false;  //flag per decidere se visualizzare segnale per segnale
   bool fit_signal=true;  //flag per decidere se effettuare o meno il fit per determinare il tempo di salita
   int fit_range_low=0;   //limite inferiore intervallo di fit
   int fit_range_hi=600;    //limite superiore intervallo di fit
   // fine definizione parametri

   //definire una canvas
   TCanvas * draw_canvas=new TCanvas("draw_canvas","draw_canvas");
   //definizione di un frame per visualizzare il segnale
   TH2F * h_signal_frame=new TH2F("","",(time_range_hi-time_range_low)/1000,time_range_low,time_range_hi,4096,0,4906);
   //definizione della funzione di fit per i tempi  
   TF1 * fd=new TF1("fd","-1*[0]/(1+exp(((-x+[1])/[2])))+[3]",fit_range_low,fit_range_hi);
   //histogramma dei tempi misurati
   TH1F* h_time=new TH1F("h_time","time; signal time [ns]; entries",1000,-500,500);

   //apertura del file dei dati nel formato root
   if (fChain == 0) return;
   Long64_t nentries = fChain->GetEntriesFast();
   cout<<"opening file "<<RootFile<<" with "<<nentries<< " entries"<<endl;
   
   // loop su tutti gli eventi
   Long64_t nbytes = 0, nb = 0;
   for (Long64_t jentry=0; jentry<nentries;jentry++) {
      Long64_t ientry = LoadTree(jentry);
      if (ientry < 0){
	cout<<"problem with event "<<jentry<<endl;
	break;
      }      
      bool test=true;
      nb = fChain->GetEntry(jentry);   nbytes += nb;


      if(jentry%100==0) cout<< "    .... event "<<ev_no<< " jentry= "<<jentry<<endl;
      TGraph * h_signal = new TGraph();  //grafico per visualizzare il segnale

      //loop su tutti i bin del segnale
      for(int i=0; i<nbins-1; i++){	
	// qui dentro tutto quello che si vuole

	// ad esempio, riempire un grafico col segnale del canale 0
	h_signal->SetPoint(i,(float)data_bin_ch1->at(i),(float)data_value_ch1->at(i));
      }
     
      // fare un fit al segnale del canale 0
      fd->SetParameter(0,1000);
      fd->SetParameter(1,400);
      fd->SetParameter(2,1);
      fd->SetParameter(3,4000);
      h_signal->Fit("fd","Q"," ",fit_range_low,fit_range_hi);
      double ttime=fd->GetParameter(1);
      h_time->Fill(ttime*0.2);

      //Disegnare il segnale del canale 0
      if(draw_signal){
	h_signal->SetMarkerStyle(20); 
	h_signal->SetMarkerSize(0.4);
	TString tit_string="event - ";
	tit_string+=ev_no;
	h_signal_frame->SetTitle(tit_string); 
	h_signal_frame->GetXaxis()->SetTitle("time bin");
	h_signal_frame->GetYaxis()->SetTitle("ADC counts");
	h_signal_frame->Draw();
	h_signal->Draw("P");
	draw_canvas->WaitPrimitive();
      }      

   } // fine loop sugli eventi
   
}
